# Task-Specific Metrics Schema
# Defines which metrics are valid for each task type
#
# Keys are actual JSON field names persisted in metrics.json (not display names)
# Schema loaded once and cached via @lru_cache

regression:
  # Distribution stats for continuous targets
  target_stats:
    - y_mean
    - y_std
    - y_min
    - y_max
    - y_finite_pct
  # Fields that should NEVER appear for regression
  exclude:
    - pos_rate
    - class_balance
    - precision
    - recall
    - f1

binary_classification:
  # Class balance stats for binary targets
  target_stats:
    - pos_rate        # Fraction of samples with pos_label
    - class_balance   # Dict of {label: count}
  # Default positive label (override in TaskSpec if needed)
  pos_label: 1
  # Fields that should NEVER appear for binary classification
  exclude:
    - y_mean
    - y_std
    - y_min
    - y_max
    - r2
    - rmse
    - mae

multiclass_classification:
  # Class balance stats for multiclass targets
  target_stats:
    - class_balance   # Dict of {label: count}
    - n_classes       # Number of unique classes
  # pos_rate is NOT emitted for multiclass (use class_balance instead)
  exclude:
    - pos_rate
    - y_mean
    - y_std
    - y_min
    - y_max
    - r2
    - rmse
    - mae

# =============================================================================
# Canonical Metric Naming
# =============================================================================
# Format: <metric_base>__<view>__<aggregation>
# - view: cs (cross-sectional) or sym (symbol-specific)
# - aggregation: mean, std, pooled
#
# This eliminates the overloaded "auc" field that stored different metrics
# depending on task type (R2 for regression, ROC-AUC for binary, etc.)

canonical_names:
  regression:
    cross_sectional:
      # Rank IC (Spearman correlation per timestamp, averaged over time)
      primary: spearman_ic__cs__mean
      std: spearman_ic__cs__std
      secondary:
        - r2__cs__pooled
        - mae__cs__pooled
    symbol_specific:
      # R2 per symbol over time, averaged across symbols
      primary: r2__sym__mean
      std: r2__sym__std
      secondary:
        - spearman_corr__sym__mean
        - rmse__sym__mean
  
  binary_classification:
    cross_sectional:
      # ROC-AUC per timestamp, averaged over time
      primary: roc_auc__cs__mean
      std: roc_auc__cs__std
      secondary:
        - pr_auc__cs__mean
        - log_loss__cs__mean
    symbol_specific:
      # ROC-AUC per symbol over time, averaged across symbols
      primary: roc_auc__sym__mean
      std: roc_auc__sym__std
      secondary:
        - pr_auc__sym__mean
  
  multiclass_classification:
    cross_sectional:
      primary: accuracy__cs__mean
      std: accuracy__cs__std
      secondary:
        - macro_f1__cs__mean
    symbol_specific:
      primary: accuracy__sym__mean
      std: accuracy__sym__std

# =============================================================================
# Scoring Configuration (P1)
# =============================================================================
# Versioned parameters for composite score calculation.
# Hash of this section becomes scoring_signature for reproducibility.
#
# The t-stat based scoring provides a bounded [0,1] skill score that's
# comparable across task types and aggregation methods.

scoring:
  version: "1.0"
  
  # Skill normalization via t-stat
  # skill_tstat = mean / (std / sqrt(n))
  # skill_score_01 = sigmoid(skill_tstat / skill_squash_k)
  skill_squash_k: 3.0  # Higher = more compression toward 0.5
  
  # Stability normalization
  # stability = 1 - clamp(std / std_ref, 0, 1)
  std_ref: 0.2  # Reference std for normalization (task-type dependent override below)
  
  # Per-task std_ref overrides (if different from default)
  std_ref_by_task:
    regression: 0.2  # Typical std for RÂ² / IC
    binary_classification: 0.15  # Typical std for ROC-AUC
    multiclass_classification: 0.2  # Typical std for accuracy
  
  # Component weights (must sum to 1.0)
  weights:
    performance: 0.50  # skill_score_01
    coverage: 0.25     # n_cs_valid / n_cs_total
    stability: 0.25    # 1 - clamp(std / std_ref, 0, 1)
  
  # Model bonus (multiplicative boost for model agreement)
  model_bonus:
    enabled: true
    max_bonus: 0.10    # Maximum 10% boost
    per_model: 0.02    # 2% per model
